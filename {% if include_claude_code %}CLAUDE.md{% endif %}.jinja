# AI Assistant Instructions

This file provides guidance for AI assistants working with this codebase.

## Project Overview

**{{ project_name }}**: {{ project_description }}

[Add key architectural decisions and module structure here]

## Workflow Principles

### Communication
- Ask for clarification when requirements are ambiguous or involve architectural decisions
- Proceed autonomously for straightforward implementations that follow existing patterns
- Provide concise updates; avoid unnecessary preamble or explanations unless requested

### Code Philosophy
- Favor simplicity and clarity over cleverness
- Prefer pure functions over classes unless state management is required
- Avoid deeply nested conditionals; use early returns instead
- Use required parameters by default; avoid `X | None` unless truly optional
- No backward compatibility required for new features unless specified

### File Organization
- Use meaningful file and module names that reflect their purpose
- Group related functionality together
- Add brief comments only for non-obvious logic or decisions
- Keep test files parallel to source files

## Development Commands

All Python commands must be prefixed with `uv run`:

```bash
# Package management
uv add <package>              # Add new package
uv sync --all-groups          # Update environment

# Code quality
make lint                     # Lint, auto-fix, format, and type check
make lint-unsafe              # Same with unsafe auto-fixes

# Testing
uv run pytest                 # Run tests
```

## Python Style Guide

### Language Version
- Python 3.13+
- Do **not** add `from __future__ import annotations` — native syntax is fully supported at this version

### Naming Conventions
- `snake_case`: functions, variables, modules
- `PascalCase`: classes
- `SCREAMING_SNAKE_CASE`: constants
- `type` keyword for type aliases: `type Vector = list[float]`

### Type Hints
- Required for all function parameters and return types
- Use `|` for unions: `str | None`, `int | float`
- Use built-in generics directly: `list[int]`, `dict[str, str]`, `tuple[int, ...]`
- Use `type` keyword for type aliases (Python 3.12+): `type Callback = Callable[[int], str]`
- Use `typing.override` for overriding methods in subclasses

### Imports
- Use absolute imports: `from package.module import symbol`
- Group imports: stdlib → third-party → local (separated by blank lines)
- Sort alphabetically within groups (ruff handles this automatically)
- Import from `typing` only for constructs not yet in builtins (`Protocol`, `TypeVar`, `overload`, etc.)

### Functions
- Keep functions focused on a single responsibility
- Use early returns to reduce nesting
- Prefer keyword arguments for calls with multiple parameters of the same type

### Error Handling
- Use specific exception types (`ValueError`, `FileNotFoundError`, etc.)
- Avoid bare `except:` clauses
- Prefer built-in exceptions over custom ones unless semantics differ

### Documentation
- Use Google-style docstrings
- Don't duplicate type information already in signatures
- Document the "why", not the "what", for non-obvious code
- Add usage examples in README.md for public APIs

### Logging
- Use `loguru` for all logging: `from loguru import logger`
- Log at appropriate levels (`logger.debug`, `logger.info`, `logger.warning`, `logger.error`)
- Do not use the stdlib `logging` module directly

### CLIs
- Use `typer` for all command-line interfaces
- Annotate parameters with types and `typer.Option`/`typer.Argument` for help text
- Keep command logic thin — delegate to core functions

### Output Formatting
- Use `rich` for structured terminal output (tables, panels, progress bars)
- Avoid excessive styling; prefer plain text output with light use of colour for emphasis
- Never use `rich` markup in log messages or exception text

### Data Validation
- Use Pydantic models with descriptive field annotations
- Validate at system boundaries (API inputs, file parsing, CLI args)

## Tooling

| Tool | Purpose | Command |
|------|---------|---------|
| ruff | Linting + formatting | `uv run ruff check . --fix && uv run ruff format .` |
| ty | Type checking | `uv run ty check` |
| pytest | Testing | `uv run pytest` |
| pre-commit | Git hooks (lint on commit) | installed via `make init` |

Ruff is configured with line length 120 and Google-style docstrings.

## Testing Guidelines

- Write tests for all new features and bug fixes
- Use descriptive test names that explain what is being tested: `test_<function>_<scenario>`
- Mark slow tests with `@pytest.mark.slow`
- Use fixtures for common test setup
- Tests live alongside source under `tests/` (importlib mode enabled)

## Quality Checklist

After implementing features:
1. Run linter and type checker: `make lint`
2. Run tests: `uv run pytest`
3. Update README.md if adding public APIs
4. Verify code follows style guidelines above
