# AI Assistant Instructions

This file provides guidance for AI assistants working with this codebase.

## Project Overview

[Add project description and key architectural decisions here]

## Workflow Principles

### Communication
- Ask for clarification when requirements are ambiguous or involve architectural decisions
- Proceed autonomously for straightforward implementations that follow existing patterns
- Provide concise updates; avoid unnecessary preamble or explanations unless requested
- Reference code locations using `file_path:line_number` format

### Code Philosophy
- Favor simplicity and clarity over cleverness
- Prefer pure functions over classes unless state management is required
- Avoid deeply nested conditionals; refactor into separate functions or use early returns
- Keep files under 300 lines; split larger files by responsibility
- Use required parameters by default; avoid `Optional` unless truly needed
- No backward compatibility required for new features unless specified

### File Organization
- Use meaningful file and module names that reflect their purpose
- Group related functionality together
- Add brief comments for complex logic or non-obvious decisions
- Keep test files parallel to source files

## Development Commands

All Python commands must be prefixed with `uv run`:

```bash
# Package management
uv add <package>              # Add new package
uv sync --all-groups          # Update environment

# Code quality
uv run ruff check . --fix     # Lint and auto-fix
uv run ruff format .          # Format code

# Testing
uv run pytest                 # Run fast tests
uv run pytest -m slow         # Run slow tests only
uv run pytest -m "slow or not slow"  # Run all tests
```

## Python Style Guide

### Language Version
- Python 3.11+ with type annotations
- Start files with `from __future__ import annotations`

### Naming Conventions
- `snake_case`: functions, variables, modules
- `PascalCase`: classes, type aliases
- `SCREAMING_SNAKE_CASE`: constants

### Type Hints
- Required for all function parameters and return types
- Use `|` for unions (e.g., `str | None`)
- Leverage Pydantic models for complex data validation

### Imports
- Use absolute imports: `from package.module import symbol`
- Group imports: stdlib, third-party, local (separated by blank lines)
- Sort alphabetically within groups

### Functions
- Pass first argument positionally; remaining as keyword arguments
- Keep functions focused on a single responsibility
- Use early returns to reduce nesting

### Error Handling
- Use specific exception types (e.g., `ValueError`, `FileNotFoundError`)
- Avoid bare `except:` clauses
- Prefer built-in exceptions over custom ones

### Documentation
- Use Google-style docstrings
- Don't duplicate type information (already in type hints)
- Document the "why" not the "what" for non-obvious code
- Add usage examples in README.md for public APIs

### Data Validation
- Use Pydantic models with descriptive field annotations
- Validate at system boundaries (API inputs, file parsing, etc.)

## Testing Guidelines

- Write tests for all new features and bug fixes
- Use descriptive test names that explain what is being tested
- Mark slow tests with `@pytest.mark.slow`
- Use fixtures for common test setup

## Quality Checklist

After implementing features:
1. Run linter: `uv run ruff check . --fix`
2. Run formatter: `uv run ruff format .`
3. Run tests: `uv run pytest`
4. Update README.md if adding public APIs
5. Verify code follows style guidelines
